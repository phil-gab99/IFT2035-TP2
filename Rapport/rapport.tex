\documentclass[12pt, titlepage]{article}

\usepackage[margin=0.75in]{geometry}
\usepackage{amsmath, amssymb}
\usepackage{microtype}
\usepackage{titlesec}

% Code snippets
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
    language=Prolog,
    showstringspaces=false,
    columns=flexible,
    basicstyle={\small\ttfamily},
    numbers=none,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{blue},
    commentstyle=\color{dkgreen},
    stringstyle=\color{mauve},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=4
}

\titlespacing{\section}{0pt}{*1.5}{*1.5}

\begin{document}

\title{{\Huge \textbf{TP2 - Rapport}}}
\author{Philippe Gabriel \\ Yan Zhuang}
\date{21 juin 2021}

\maketitle

\pagenumbering{arabic}
\setcounter{page}{2}

\newpage

\section{Premier aperçu}
Comme première étape de travail, nous avions tenter d'apparier les données de
ce travail avec celui du premier travail pratique. Nous avions donc commencer
par supposer que les relations \texttt{infer} et \texttt{check} devrait
ressembler à aux fonctions du même nom dans le premier travail, et que les
relations \texttt{expand} et \texttt{coerce} ressemblait en quelque sorte à
\texttt{s2l}. Nous avions vite remarqué que de telles suppositions étaient
fausses à prendre, surtout dans la méthode d'implémentation car on remarque
dans le travail sur le langage \texttt{psil} que l'on peut diviser le travail
en quatre phases distinctes qui est même reflété par l'implémentation.
Cependant, pour le langage $\mu$\texttt{pts}, les relations communiquent toutes
entre elles en quelque sorte. Cela a rendu la tâche assez difficile au début.
La technique que l'on a employé par après pour ce travail est une sorte de
"Test-driven development" (tdd). On roulait les tests à l'aide de
\texttt{test\_samples} en appliquant l'outil de déboguage \texttt{trace}
qu'offre l'environnement de \texttt{prolog}. Cela nous permet de situer
l'emplacement des échecs d'exécution et nous permet par la suite de
corriger ceux-ci.

\section{Initialiser l'environnement}
La première erreur qui apparaissait après le démarrage des tests était l'échec
de l'inférence du type \texttt{type}. Nous regardons donc la figure de la
donnée indiquant les règles de typage bidirectionnelles du langage surface et
on s'apeçoit que la règle suivante semble s'appliquer à notre situation:
\begin{equation*}
    \frac {\Gamma(x) = e} {\Gamma \vdash x \Rightarrow e}
\end{equation*}
Nous avions donc rajouté une règle d'inférence supplémentaire comme-ci:
\begin{lstlisting}
% Regle 1
infer(Env, X, X, T) :-
    member(X : T, Env).
\end{lstlisting}
Cela a donc permis l'élaboration de l'environnement des types \texttt{int},
\texttt{float} et \texttt{bool}. Nous avions continué cette approche pour les
autres types en ajoutant, au fur et à mesure, les règles nécessaires pour le
passage de ces tests. Pour le type du \texttt{if}, il nous a été nécessaire
d'ajouter un cas supplémentaire dans nos règles d'expansion comme suit:
\begin{lstlisting}
expand(forall(X, B), forall(X, _, B)).
\end{lstlisting}
Cela nous a permis de faire passer le test pour \texttt{if}. Un problème est
ensuite survenu pour \texttt{nil}, où on avait affair pour la première fois
à une construction de \texttt{functor}. Il nous fallait la décomposer en
langage interne en ajoutant un cas supplémentaire à \texttt{expand}. Il nous a
été nécessaire d'écrire plusieurs versions de ce cas après plusieurs tests
individuelles pour finalement arriver à cette forme:
\begin{lstlisting}
expand(Fa, app(Fb, AL)) :-
    Fa =.. [N | AS],
    \+ member(N, [fun, app, arw, forall, (->), (:), let, [], (.)]),
    length(AS, L),
    L \= 0,
    functor(Fa, N, L),
    last(AS, AL),
    append(AI, [AL], AS),
    Fb =.. [N | AI].
\end{lstlisting}
Après cela, le cas particulier du type de \texttt{cons}, qui prend une liste de
paramètres nous a donc inciter à modifier notre définition d'expansion d'un
\texttt{forall} de sorte à l'élaborer en des \texttt{forall} currifiés:
\begin{lstlisting}
expand(forall(X, B), F) :-
    (X = [T | TS], TS \= [] ->
            F = forall(T, _, forall(TS, B));
            (X = [A] ->
                F = forall(A, _, B);
                F = forall(X, _, B))).
\end{lstlisting}
Suite à cette modification et à d'autres ajouts de règles de typages,
l'initialisation de l'environnement était complète.
\section{Test d'expressions}
\end{document}